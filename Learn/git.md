- [计算机硬件的操作](#计算机硬件的操作)
- [计算机硬件的操作数](#计算机硬件的操作数)
  - [存储器操作数](#存储器操作数)
  - [常数(立即操作数)](#常数立即操作数)
- [计算机中指令的表示](#计算机中指令的表示)
- [逻辑运算](#逻辑运算)
- [分支指令](#分支指令)
  - [循环](#循环)
- [计算机硬件的过程支持](#计算机硬件的过程支持)
  - [嵌套过程](#嵌套过程)
- [人机交互](#人机交互)
- [对 32 位立即数的 MIPS 编址和寻址](#对-32-位立即数的-mips-编址和寻址)
- [总结](#总结)

## 计算机硬件的操作
1. 简单源自规整

## 计算机硬件的操作数
2. 越少越快 (指寄存器个数, 不绝对)

### 存储器操作数
* lw 取字, sw 存储字
* 存储器中地址的偏移量为 4 的倍数, 起始地址也为 4 的倍数

### 常数(立即操作数)
3. 加速执行常用操作

## 计算机中指令的表示
* 指令格式 : 6-5-5-5-5-6
* p51 : op - rs - rt - -rd - shamt - funct (R)

4. 优秀的设计需要适当的折中

* I : op - rs - rt - constant or address
  *   6 - 5 - 5 - 16

* sw 和 lw 都是前为寄存器, 后为存储器

## 逻辑运算


## 分支指令
```C
if(i == j) 
  f = g + h;
else
  f = g - h;
```
* 翻译时使用'go'跳过==
```
bne $s3.$s4.Else  # 第一步使用 bne 先判断否的条件
add $s0.$s1.$s2
j Exit
Else : sub $s0.$s1.$s2
Exit:
```

### 循环
```c
while(save[i] == k)
  i += 1;
```

```c
Loop: sll  $t1.$s3.2  // 将 i 左移两位寄存到 $t1

```

* slt , 小于则置一
* slt==i== , 立即数版本

---

## 计算机硬件的过程支持
* jal : 跳转到某个地址的同时将下一条指令的地址保存在 $ra
* jr $ra : 寄存器跳转指令

### 嵌套过程
* 注意理解 p65

## 人机交互
* lb 读取字节
* sb 保存字节

## 对 32 位立即数的 MIPS 编址和寻址
* lui 取立即数高位(16位)
* ori 取立即数地位(16位)

```
beq $s0.$s1.L1

bne $s0.$s1.L2
j L1
L2:
```
* 下面提供了大得多的分支转移距离

* p78 表格

* c语言之中的 sort 的 MIPS 汇编语言
* P94

* 字节寻址的机器中, ==连续的字地址相差 4==

---

## 总结
> ![](image/2022-03-09-21-14-48.png)
> ![](image/2022-03-09-21-15-08.png)
> ![](image/2022-03-09-21-16-44.png)

---

> ![](image/2022-03-09-21-16-12.png)